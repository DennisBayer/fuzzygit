#!/usr/bin/env bash
#   __                           _ _
#  / _|_   _ _________   _  __ _(_) |_
# | |_| | | |_  /_  / | | |/ _` | | __|
# |  _| |_| |/ / / /| |_| | (_| | | |_
# |_|  \__,_/___/___|\__, |\__, |_|\__|
#                    |___/ |___/
#
# fuzzygit - marry git and fzf
#

# Fuzzygit config
fg_var_enableEcho=true

# Git config
fg_var_gitPager=$(git config core.pager)

# -----------------------------------------------------------------------------
# Utility functions
# -----------------------------------------------------------------------------

fg_isGitRepo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fg_echo() {
  [ "$fg_var_enableEcho" != true ] && return 0;

  if [[ "$#" -ne 0 ]]; then
    echo "$@" | xargs -r echo
  fi
}

# -----------------------------------------------------------------------------
# fzf functions
# -----------------------------------------------------------------------------

fg_fzf() {
  # --exact
  fzf --cycle "$@"
}

fg_fzf_single() {
  fzf --cycle +m "$@"
}

# -----------------------------------------------------------------------------
# fuzzygit functions
# -----------------------------------------------------------------------------

#
# Shows a list of local branches and switches to the selected one.
#
fg_switch() {
  fg_isGitRepo || return 1

  # strip the two leading spaces ("* <branch>")
  local sanatize="sed 's/^..//'"

  # get log of branches
  local preview="git log --oneline --graph \$("$sanatize" <<< {})"

  # get branches; single selection;
  local item="$(git branch -l |
    fg_fzf_single --preview="$preview" |
    sh -c "$sanatize")"

  # switch to branch if any
  if [[ -n "$item" ]]; then
    local gitout="$(echo "$item" | xargs -I %branch git switch %branch) \
      && fg_echo "$gitout""
  else
    fg_echo "No branches have been found."
  fi
}

#
# Shows a list of addable files and adds them to the staging area.
#
fg_add() {
  fg_isGitRepo || return 1

  # strip the three leading charactes ("?? <file>")
  local sanatize="sed 's/^...//'"

  # check if file is untracked; show pager in preview accordingly
  local preview="item=\$("$sanatize" <<< {})
    if (git status -s -- \""\$item"\" | grep '^??') &>/dev/null; then
        # diff with /dev/null for untracked files
        git diff --no-index -- /dev/null \""\$item"\" | "$fg_var_gitPager"
    elif (git status -s -- \""\$item"\" | grep '^[M|A]'); then
        git diff --staged -- \""\$item"\" | "$fg_var_gitPager"
    else
        git diff -- \""\$item"\" | "$fg_var_gitPager"
    fi"

  # get parsable status; show preview and limit search to second block
  local items="$(git status -zu |
    fg_fzf --read0 --nth 2..,.. --preview="$preview" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  add selected files to staging area; add single quote to escape whitespaces in file names
    local gitout="$(echo "$items" | xargs -t -I %itemsToAdd git add -- '%itemsToAdd') \
      && fg_echo "$gitout""
  else
    fg_echo "No files have been found."
  fi
}

#
# Shows the list of files which are in the staging area (aka added files)
# and puts them back into the working area.
#
fg_unstage() {
  fg_isGitRepo || return 1

  # strip the three leading charactes ("?? <file>")
  local sanatize="sed 's/^...//'"

  # show diff in pager
  local preview="item=\$("$sanatize" <<< {})
    git diff --staged -- \""\$item"\" | "$fg_var_gitPager""

  # get parsable status; show preview and limit search to second block
  local items="$(git status -s -uno | 
    grep -E "^[MARCD][[:space:]]?" |
    fg_fzf --nth 2..,.. --preview="$preview" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  remove selected files from staging area; add single quote to escape whitespaces in file names
    local gitout="$(echo "$items" | xargs -t -I %itemsToUnstage git restore --staged -- '%itemsToUnstage') \
      && fg_echo "$gitout""
  else
    fg_echo "No files have been selected."
  fi
}

#
# Show the list of files in the working area (aka modified files)
# and restores the version from the local repository.
#
fg_restore() {
  fg_isGitRepo || return 1

  # strip the three leading charactes ("?? <file>")
  local sanatize="sed 's/^...//'"

  # show diff in pager
  local preview="item=\$("$sanatize" <<< {})
    git diff -- \""\$item"\" | "$fg_var_gitPager""

  # get parsable status; show preview and limit search to second block
  local items="$(git status -s -uno | 
    grep "^ M" |
    fg_fzf --nth 2..,.. --preview="$preview" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  restore selected files from working directory; add single quote to escape whitespaces in file names
    local gitout="$(echo "$items" | xargs -t -I %itemsToRestore git restore -- '%itemsToRestore') \
      && fg_echo "$gitout""
  else
    fg_echo "No files have been selected."
  fi
}

#
# Shows the commit history and shows the log between the selected one and the HEAD.
#
fg_log() {
  fg_isGitRepo || return 1

  # show the highlighted commit with "--stats" option
  local preview="git log -1 --stat {1}"

  # show a short git log
  local item="$(git log --oneline | fg_fzf_single --preview="$preview")"

  # show the commit log between the selected commit and the current head
  if [[ -n "$item" ]]; then
    echo "$item" | awk '{print $1}' | xargs -I %commitHash% git log --stat %commitHash%^..HEAD
  else
    fg_echo "No commit has been selected."
  fi
}

#
# Shows the commit history and passes the hashes of the selected entries
# to the command which was given as an argument.
#
fg_hash() {
  fg_isGitRepo || return 1

  # show the highlighted commit with "--stats" option
  local preview="git log -1 --stat {1}"

  # show a short git log
  local items="$(git log --oneline | fg_fzf --preview="$preview")"

  # pass the selected commit hashes to the argument, e.g. "fg_hash git show"
  if [[ -n "$items" ]]; then
    echo "$items" | awk '{print $1}' | xargs -I %commitHash% "$@" %commitHash%
  else
    fg_echo "No commit has been selected."
  fi
}

#bind '"\er": redraw-current-line'
#bind '"\C-g\C-b": "$(fg_switch)\n\e\C-e\er"'
#bind '"\C-g\C-h": "$(fg_hash)\n\e\C-e\er"'

# \e\C-e is the default key binding for shell-expand-line. 
#   Using shell-expand-line is not ideal as it expands aliases as well, but it's the easiest way to do it.
# redraw-current-line is required to clear up the prompt when you're not on tmux. 
#   If you're always on tmux, you can omit the part.

  #local git="git status -sz" # s: short; z: NUL instead LF
  #local extract="
  #    sed 's/^.*]  //' |
  #    sed 's/.* -> //' |
  #    sed -e 's/^\\\"//' -e 's/\\\"\$//'"
  #files="$(git)"
  #[[ -n "$files" ]] 

# ---
# --- NOTES 
# ---

# ---
# fzf field index expresions
#
# -- {+<>} - all selections when multiple lines are selected
# -- {s}  - preserve the whitespace
# -- {q}  - the current query string
# -- {n}  - zero-based ordinal index of the line
# -- {f}  - the path of a temporary file that holds the evaluated list
# 1      The 1st field
# 2      The 2nd field
# -1     The last field
# -2     The 2nd to last field
# 3..5   From the 3rd field to the 5th field
# 2..    From the 2nd field to the last field
# ..-3   From the 1st field to the 3rd to the last field
# ..     All the fields

# ---
# sed s/^..//
  # s   - search and replace
  # /   - start pattern
  # ^.. - line start and any char two times
  # /   - end pattern
  # /   - no replacement was defined before slash -> remove match

## fg_switch
#echo "$gitout" | xargs -r echo
#echo "$items" | fzf --preview="$preview" --print0 | sh -c "$sanatize" | xargs --null -I %branch git switch %branch >&1 | xargs -r echo
# ---

# ---
## fg_add
# fg_add() {
#   fg_isGitRepo || return 1
#   gitPager=$(git config core.pager)
#   echo $gitPager
#   $(git status -s | fzf -m --cycle --nth 2.. --preview 'git diff --staged -- {-1} | "$gitPager"')
# }

# git st -su | xargs --null -I % echo % | sed 's/^...//' | sed 's/.*.-> //'
# git -c color.status=always status -su | fg_fzf --ansi | sed 's/^...//' | sed 's/.*.-> //'
# ---

# ---
  # local sanatizePreview="sed 's/^...//'"                                     # strip the two leading spaces
  # local sanatizeSelection="sed 's/^...//'"
# ---


# ---
  # local added=$(git config --get-color color.status.added green)       # get color codes
  # local changed=$(git config --get-color color.status.changed red)     # get color codes
  # local unmerged=$(git config --get-color color.status.unmerged red)   # get color codes
  # local untracked=$(git config --get-color color.status.untracked red) # get color codes

  # #local items="$(git -c color.status=always status -su |
  #   #grep -F -e "$added" -e "$changed" -e "$unmerged" -e "$untracked" |
  #   #sed -E 's/^(..[^[:space:]]*)[[:space:]]+(.*)$/[\1]  \2/')"
  # # local items="$(git -c color.status=always status -su | 
  # #   sed -E 's/^(..[^[:space:]]*)[[:space:]]+(.*)$/[\1]  \2/' |
  # #   fg_fzf --preview="$preview" --nth 2..,..)"

  # # local items="$(git -c color.status=always -c status.relativePaths=true status -su |
  # #   grep -F -e "$changed" -e "$unmerged" -e "$untracked" |
  # #   sed -E 's/^(..[^[:space:]]*)[[:space:]]+(.*)$/[\1]  \2/'|
  # #   fg_fzf --preview="$preview" --nth 2..,..)"
# ---

# ---
##local gitout=$(echo "$items" | fg_fzf --preview="$preview" --print0 | sh -c "$sanatize" | xargs -t --null -I %filesToAdd git add %filesToAdd) \
##&& fg_echo gitout
#local gitout=$(echo "$items" | fg_fzf --preview="$preview" --nth 2..,.. | xargs -t --null sh -c "$sanatizeSelection" | xargs -t --null -I %filesToAdd git add %filesToAdd) \
#local gitout=$(echo "$items" | fg_fzf --preview="$preview" --nth 2..,.. | xargs -t --null sh -c "$sanatizeSelection" | xargs -t --null -I %filesToAdd echo %filesToAdd) \
#&& fg_echo "$gitout"
# ---
