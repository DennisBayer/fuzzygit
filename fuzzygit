#!/usr/bin/env bash
#   __                           _ _
#  / _|_   _ _________   _  __ _(_) |_
# | |_| | | |_  /_  / | | |/ _` | | __|
# |  _| |_| |/ / / /| |_| | (_| | | |_
# |_|  \__,_/___/___|\__, |\__, |_|\__|
#                    |___/ |___/
#
# fuzzygit - marry git and fzf
#

# Fuzzygit config
fg_var_enableEcho=true

# Git config
fg_var_gitPager=$(git config core.pager)

# -----------------------------------------------------------------------------
# Utility functions
# -----------------------------------------------------------------------------

fg_isGitRepo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fg_echo() {
  [ "$fg_var_enableEcho" != true ] && return 0;

  if [[ "$#" -ne 0 ]]; then
    #echo "$@" | xargs -r echo
    printf "%s\n" "$@"
  fi
}

fg_header() {
  # echo -e "
  #   \e[1m"$1"\e[0m - "$2"
  # "
  printf "
    \e[1m%s\e[0m 
    \t%s
  " "$1" "$2"
}

#
# Strip the three leading charactes ("?? <item>") and if ' -> ' is contained
# keep the part afterwards only.
#
FG_GIT_STATUS_PATTERN="'s/^...//; s/.*->.//'"

#
# Strip the two leading spaces ("* <branch>")
#
FG_GIT_SWITCH_PATTERN="'s/^..//'"

#
# Print a pretty log, e.g <hash> - <relative date> <commit message> - <author>
#
FG_GIT_LOG_PRETTY_FORMAT="--pretty=format:%h - (%ar) %C(bold)%s%C(reset) - %aN"

# -----------------------------------------------------------------------------
# fzf functions
# -----------------------------------------------------------------------------

fg_fzf() {
  # --exact
  fzf --cycle "$@"
}

fg_fzf_single() {
  fzf --cycle +m "$@"
}

# -----------------------------------------------------------------------------
# fuzzygit functions
# -----------------------------------------------------------------------------

#
# Main function.
#
# The first argument refers to the function which should be invoked, e.g.
# `fg add` will call `fg_add`.
# The remaining arguments are passed to the calling function, e.g.
# `fg hash git show` will call `fg_hash git show`.
#
fg() {
  fg_isGitRepo || return 1

  if [[ "$#" -ne 0 ]]; then
    fg_"$1" "${@:2:($#-1)}"
  else
    fg_echo "No argument was given, e.g: \"fg add\"."
  fi
}

#
# Shows a list of local branches and switches to the selected one.
# 
# Passed arguments are added to the branch listing, 
# e.g. `-r` will list remote branches.
#
fg_switch() {
  fg_isGitRepo || return 1

  # strip the two leading spaces ("* <branch>")
  local sanatize="sed "$FG_GIT_SWITCH_PATTERN""

  # get log of branches
  local preview="git log '"$FG_GIT_LOG_PRETTY_FORMAT"' \$("$sanatize" <<< {})"

  local header="$(fg_header \
    "git switch <selected branch>" \
    "Switch or checkout the branch.")"

  # get branches; single selection;
  local item="$(git branch -l "$@" |
    fg_fzf_single --preview="$preview" --header="$header" |
    sh -c "$sanatize")"

  # switch to branch if any
  if [[ -n "$item" ]]; then
    local gitout="$(echo "$item" | xargs -I %branch git switch %branch) \
      && fg_echo "$gitout""
  else
    fg_echo "No branch has been selected."
  fi
}

#
# Shows a list of addable files and adds them to the staging area.
#
fg_add() {
  fg_isGitRepo || return 1

  local sanatize="sed "$FG_GIT_STATUS_PATTERN""

  # check if file is untracked; show pager in preview accordingly
  local preview="item=\$("$sanatize" <<< {})
    if (git status -s -- \""\$item"\" | grep '^??') &>/dev/null; then
        # diff with /dev/null for untracked files
        git diff --no-index -- /dev/null \""\$item"\" | "$fg_var_gitPager"
    elif (git status -s -- \""\$item"\" | grep '^[M|A]'); then
        git diff --staged -- \""\$item"\" | "$fg_var_gitPager"
    else
        git diff -- \""\$item"\" | "$fg_var_gitPager"
    fi"

  local header="$(fg_header \
    "git add -- <selected items>" \
    "Adds items to the staging area.")"

  # get parsable status; show preview and limit search to second block
  local items="$(git status -su |
    grep -v -E '^[MARCD][[:space:]]' |
    fg_fzf --nth 2..,.. --preview="$preview" --header="$header" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  add selected files to staging area; add single quote to escape whitespaces in file names
    local gitout="$(echo "$items" | xargs -t -I %itemsToAdd git add -- '%itemsToAdd') \
      && fg_echo "$gitout""
  else
    fg_echo "No files have been selected."
  fi
}

#
# Shows the list of files which are in the staging area (aka added files)
# and puts them back into the working area.
#
fg_unstage() {
  fg_isGitRepo || return 1

  local sanatize="sed "$FG_GIT_STATUS_PATTERN""

  # show diff in pager
  local preview="item=\$("$sanatize" <<< {})
    git diff --staged -- \""\$item"\" | "$fg_var_gitPager""

  local header="$(fg_header \
    "git restore --staged -- <selected items>" \
    "Removes items from the staging area.")"

  # get parsable status; show preview and limit search to second block
  local items="$(git status -s -uno |
    grep -E "^[MARCD][[:space:]]?" |
    fg_fzf --nth 2..,.. --preview="$preview" --header="$header" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  remove selected files from staging area; add single quote to escape whitespaces in file names
    local gitout="$(echo "$items" | xargs -t -I %itemsToUnstage git restore --staged -- '%itemsToUnstage') \
      && fg_echo "$gitout""
  else
    fg_echo "No files have been selected."
  fi
}

#
# Show the list of files in the working area (aka modified files)
# and restores the version from the local repository.
#
fg_restore() {
  fg_isGitRepo || return 1

  local sanatize="sed "$FG_GIT_STATUS_PATTERN""

  # show diff in pager
  local preview="item=\$("$sanatize" <<< {})
    git diff -- \""\$item"\" | "$fg_var_gitPager""

  local header="$(fg_header \
    "git restore -- <selected items>" \
    "Restores items from local repository.")"

  # get parsable status; show preview and limit search to second block
  local items="$(git status -s -uno |
    grep -E "^([MARCD]|[[:space:]])[MARCD]" |
    fg_fzf --nth 2..,.. --preview="$preview" --header="$header" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  restore selected files from working directory; add single quote to escape whitespaces in file names
    local gitout="$(echo "$items" | xargs -t -I %itemsToRestore git restore -- '%itemsToRestore') \
      && fg_echo "$gitout""
  else
    fg_echo "No files have been selected."
  fi
}

#
# Shows the commit history and shows the log between the selected one and the HEAD.
#
fg_log() {
  fg_isGitRepo || return 1

  # show the highlighted commit with "--stats" option
  local preview="git log -1 --stat "$@" {1}"

  local header="$(fg_header \
    "git log --stat <selected commit>^..HEAD" \
    "Shows the log starting with the selected commit up until HEAD.")"

  # show a short git log
  local item="$(git log "$FG_GIT_LOG_PRETTY_FORMAT" |
    fg_fzf_single --preview="$preview" --header="$header")"

  # show the commit log between the selected commit and the current head
  if [[ -n "$item" ]]; then
    echo "$item" | awk '{print $1}' | xargs -I %commitHash% git log --stat "$@" %commitHash%^..HEAD
  else
    fg_echo "No commit has been selected."
  fi
}

fg_flog() {
  fg_isGitRepo || return 1

  local preview="git log "$@" -- {1}"

  local header="$(fg_header \
    "git log <selected item>" \
    "Shows the log of the selected item.")"

  local item="$(git ls-tree -r --name-only $(git branch --show-current) |
    fg_fzf_single --preview="$preview" --header="$header")"

  if [[ -n "$item" ]]; then
    echo "$item" | xargs -i -I %item git log "$@" -- %item
  else
    fg_echo "No item has been selected."
  fi
}

#
# Shows the commit history and passes the hashes of the selected entries
# to the command which was given as an argument.
#
fg_hash() {
  fg_isGitRepo || return 1

  # show the highlighted commit with "--stats" option
  local preview="git log -1 --stat {1}"

  local header="$(fg_header \
    "\"\$@\" <selected commit>" \
    "Passes the selected commit to whatever was given as an argument.")"

  # show a short git log
  local items="$(git log "$FG_GIT_LOG_PRETTY_FORMAT" |
    fg_fzf --preview="$preview" --header="$header")"

  # pass the selected commit hashes to the argument, e.g. "fg_hash git show"
  if [[ -n "$items" ]]; then
    echo "$items" | awk '{print $1}' | xargs -I %commitHash% "$@" %commitHash%
  else
    fg_echo "No commit has been selected."
  fi
}
