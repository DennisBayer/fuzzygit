#!/usr/bin/env bash
#   __                           _ _
#  / _|_   _ _________   _  __ _(_) |_
# | |_| | | |_  /_  / | | |/ _` | | __|
# |  _| |_| |/ / / /| |_| | (_| | | |_
# |_|  \__,_/___/___|\__, |\__, |_|\__|
#                    |___/ |___/
#
# fuzzygit - marry git and fzf
#

# shellcheck source=/dev/null
[[ -f "${XDG_CONFIG_HOME}/fuzzygit/config" ]] && . "${XDG_CONFIG_HOME}/fuzzygit/config"

# Fuzzygit config
FUZZYGIT_IS_ECHO_STATUS=${FUZZYGIT_IS_ECHO_STATUS:-true}
FUZZYGIT_IS_PREVIEW_SED=${FUZZYGIT_IS_PREVIEW_SED:-true}

# Git config
FG_VAR_GIT_PAGER=$(git config core.pager)
FG_VAR_PREVIEW_GIT_LOG_OPTS=${FUZZYGIT_PREVIEW_GIT_LOG_OPTS:-"--stat"}

# -----------------------------------------------------------------------------
# Utility functions
# -----------------------------------------------------------------------------

fg_isGitRepo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fg_echo() {
  [ "$FUZZYGIT_IS_ECHO_STATUS" != true ] && return 0;

  if [[ "$#" -ne 0 ]]; then
    #echo "$@" | xargs -r echo
    printf "%s\n" "$@"
  fi
}

fg_header() {
  # echo -e "
  #   \e[1m"$1"\e[0m - "$2"
  # "
  printf "
    \e[1m%s\e[0m 
    \t%s
  " "$1" "$2"
}

#
# Strip the three leading charactes ("?? <item>") and if ' -> ' is contained
# keep the part afterwards only.
#
FG_GIT_STATUS_PATTERN="'s/^...//; s/.*->.//; s/\"//g'"

#
# Strip the two leading spaces ("* <branch>")
#
FG_GIT_SWITCH_PATTERN="'s/^..//'"

#
# Print a pretty log, e.g <hash> - <relative date> <commit message> - <author>
#
FG_GIT_LOG_PRETTY_FORMAT="--pretty=format:%h - (%ar)%d %C(bold)%s%C(reset) - %aN"

# -----------------------------------------------------------------------------
# fzf functions
# -----------------------------------------------------------------------------

fg_fzf() {
  fzf --cycle --layout=reverse --multi "$@"
}

fg_fzf_single() {
  fzf --cycle --layout=reverse --no-multi "$@"
}

# -----------------------------------------------------------------------------
# fuzzygit functions
# -----------------------------------------------------------------------------

#
# Main function.
#
# The first argument refers to the function which should be invoked, e.g.
# `fg add` will call `fg_add`.
# The remaining arguments are passed to the calling function, e.g.
# `fg hash git show` will call `fg_hash git show`.
#
fuzzygit() {
  fg_isGitRepo || return 1

  if [[ "$#" -ne 0 ]]; then
    fg_"$1" "${@:2:($#-1)}"
  else
    fg_echo "No argument was given, e.g: \"fg add\"."
  fi
}

#
# Shows a list of local branches and switches to the selected one.
# 
# Passed arguments are added to the branch listing, 
# e.g. `-r` will list remote branches.
#
fg_switch() {
  fg_isGitRepo || return 1

  local sanatize preview header item

  # strip the two leading spaces ("* <branch>")
  sanatize="sed $FG_GIT_SWITCH_PATTERN"

  # get log of branches
  if [[ "$FUZZYGIT_IS_PREVIEW_SED" = true ]]; then
    preview="git log '$FG_GIT_LOG_PRETTY_FORMAT' \$($sanatize <<< {})"
  else
    preview="git log '$FG_GIT_LOG_PRETTY_FORMAT' {1}"
  fi

  header="$(fg_header \
    "git switch <selected branch>" \
    "Switch or checkout the branch.")"

  item="$(git branch "${@:-"-l"}" |
    fg_fzf_single --preview="$preview" --header="$header" |
    sh -c "$sanatize")"

  # switch to branch if any
  if [[ -n "$item" ]]; then
    echo "$item" | xargs -I %branch git switch %branch
  else
    fg_echo "No branch has been selected."
  fi
}

#
# Shows a list of addable files and adds them to the staging area.
#
fg_add() {
  fg_isGitRepo || return 1

  local sanatize preview header items

  sanatize="sed $FG_GIT_STATUS_PATTERN"

  # check if file is untracked; show pager in preview accordingly
  if [[ "$FUZZYGIT_IS_PREVIEW_SED" = true ]]; then
    preview="item=\$($sanatize <<< {})
      if (git status -s -- \"\$item\" | grep '^??') &>/dev/null; then
          # diff with /dev/null for untracked files
          git diff --no-index -- /dev/null \"\$item\" | $FG_VAR_GIT_PAGER
      elif (git status -s -- \"\$item\" | grep '^[M|A][[:space:]]'); then
          git diff --staged -- \"\$item\" | $FG_VAR_GIT_PAGER
      else
          git diff -- \"\$item\" | $FG_VAR_GIT_PAGER
      fi"
  else
    preview="
      if (git status -s -- {2..} | grep '^??') &>/dev/null; then
          # diff with /dev/null for untracked files
          git diff --no-index -- /dev/null {2..} | $FG_VAR_GIT_PAGER
      elif (git status -s -- {2..} | grep '^[M|A][[:space:]]'); then
          git diff --staged -- '{2..}' | $FG_VAR_GIT_PAGER
      else
          git diff -- '{2..}' | $FG_VAR_GIT_PAGER
      fi"
  fi

  header="$(fg_header \
    "git add -- <selected items>" \
    "Adds items to the staging area.")"

  # get parsable status; show preview and limit search to second block
  items="$(git status -su |
    grep -v -E '^[MARCD][[:space:]]' |
    fg_fzf --nth 2..,.. --preview="$preview" --header="$header" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  add selected files to staging area; add single quote to escape whitespaces in file names
    echo "$items" | xargs -t -I %itemsToAdd git add -- '%itemsToAdd'
  else
    fg_echo "No files have been selected."
  fi
}

#
# Shows the list of files which are in the staging area (aka added files)
# and puts them back into the working area.
#
fg_unstage() {
  fg_isGitRepo || return 1

  local sanatize preview header items

  sanatize="sed $FG_GIT_STATUS_PATTERN"

  # show diff in pager
  if [[ "$FUZZYGIT_IS_PREVIEW_SED" = true ]]; then
    preview="item=\$($sanatize <<< {})
      git diff --staged -- \"\$item\" | $FG_VAR_GIT_PAGER"
  else 
    preview="git diff --staged -- '{2..}' | $FG_VAR_GIT_PAGER"
  fi

  header="$(fg_header \
    "git restore --staged -- <selected items>" \
    "Removes items from the staging area.")"

  # get parsable status; show preview and limit search to second block
  items="$(git status -s -uno |
    grep -E "^[MARCD][[:space:]]?" |
    fg_fzf --nth 2..,.. --preview="$preview" --header="$header" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  remove selected files from staging area; add single quote to escape whitespaces in file names
    echo "$items" | xargs -t -I %itemsToUnstage git restore --staged -- '%itemsToUnstage'
  else
    fg_echo "No files have been selected."
  fi
}

#
# Show the list of files in the working area (aka modified files)
# and restores the version from the local repository.
#
fg_restore() {
  fg_isGitRepo || return 1

  local sanatize preview header items

  sanatize="sed $FG_GIT_STATUS_PATTERN"

  # show diff in pager
  if [[ "$FUZZYGIT_IS_PREVIEW_SED" = true ]]; then
    preview="item=\$($sanatize <<< {})
      git diff -- \"\$item\" | $FG_VAR_GIT_PAGER"
  else
    preview="git diff -- '{2..}' | $FG_VAR_GIT_PAGER"
  fi

  header="$(fg_header \
    "git restore -- <selected items>" \
    "Restores items from local repository.")"

  # get parsable status; show preview and limit search to second block
  items="$(git status -s -uno |
    grep -E "^([MARCD]|[[:space:]])[MARCD]" |
    fg_fzf --nth 2..,.. --preview="$preview" --header="$header" |
    sh -c "$sanatize")"

  # add files if any
  if [[ -n "$items" ]]; then
    #  restore selected files from working directory; add single quote to escape whitespaces in file names
    echo "$items" | xargs -t -I %itemsToRestore git restore -- '%itemsToRestore'
  else
    fg_echo "No files have been selected."
  fi
}

#
# Shows the commit history and shows the log between the selected one and the HEAD.
#
fg_log() {
  fg_isGitRepo || return 1

  local preview header item

  preview="git log -1 ${*:-$FG_VAR_PREVIEW_GIT_LOG_OPTS} {1}"

  header="$(fg_header \
    "git log --stat <selected commit>^..HEAD" \
    "Shows the log starting with the selected commit up until HEAD.")"

  item="$(git log "$FG_GIT_LOG_PRETTY_FORMAT" |
    fg_fzf_single --preview="$preview" --header="$header")"

  # show the commit log between the selected commit and the current head
  if [[ -n "$item" ]]; then
    echo "$item" | awk '{print $1}' | xargs -t -I %commitHash% git log "${@:-$FG_VAR_PREVIEW_GIT_LOG_OPTS}" %commitHash%^..HEAD
  else
    fg_echo "No commit has been selected."
  fi
}

#
# Shows the files of the current branch and the detailed log for the selected item.
#
fg_flog() {
  fg_isGitRepo || return 1

  local preview header item

  preview="git log ${*:-$FG_VAR_PREVIEW_GIT_LOG_OPTS} -- {1}"

  header="$(fg_header \
    "git log <selected item>" \
    "Shows the log of the selected item.")"

  item="$(git ls-tree -r --name-only "$(git branch --show-current)" |
    fg_fzf_single --preview="$preview" --header="$header")"

  if [[ -n "$item" ]]; then
    echo "$item" | xargs -t -I %item git log "${@:-$FG_VAR_PREVIEW_GIT_LOG_OPTS}" -- %item
  else
    fg_echo "No item has been selected."
  fi
}

#
# Shows the commit history and passes the hashes of the selected entries
# to the command which was given as an argument.
#
fg_hash() {
  fg_isGitRepo || return 1

  local preview header items

  # As for now no log opts can be passed externally, because hash uses arguments 
  # to control execution.
  preview="git log -1 $FG_VAR_PREVIEW_GIT_LOG_OPTS {1}"

  header="$(fg_header \
    "\"\$@\" <selected commit>" \
    "Passes the selected commit to whatever was given as an argument.")"

  items="$(git log "$FG_GIT_LOG_PRETTY_FORMAT" |
    fg_fzf --preview="$preview" --header="$header")"

  # pass the selected commit hashes to the argument, e.g. "fg_hash git show"
  if [[ -n "$items" ]]; then
    echo "$items" | awk '{print $1}' | xargs -t -I %commitHash% "$@" %commitHash%
  else
    fg_echo "No commit has been selected."
  fi
}

#
# Cherry picks the commits from the given branch into the current one.
#
fg_cherry() {
  fg_isGitRepo || return 1
  [[ "$#" -lt 1 ]] && fg_echo "No branch to show log for has been given." && return 1

  local branch preview header items

  branch=$1
  shift

  preview="git log -1 ${*:-$FG_VAR_PREVIEW_GIT_LOG_OPTS} {1}"

  header="$(fg_header \
    "git cherry-pick -x <selected commits>" \
    "Cherry picks the selected commits.")"

  items="$(git log "$branch" "$FG_GIT_LOG_PRETTY_FORMAT" |
    fg_fzf --preview="$preview" --header="$header")"

  if [[ -n "$items" ]]; then
    echo "$items" | awk '{print $1}' | tac | xargs -t -I %commitHash% git cherry-pick -x %commitHash%
  else
    fg_echo "No commit has been selected."
  fi
}
